#!/usr/bin/env node

import { writeFile, mkdir } from 'fs/promises'
import { join } from 'path'
import { fileURLToPath } from 'url'
import { dirname } from 'path'
import { find as findTz } from 'geo-tz/all'
import createFetch from 'make-fetch-happen'
import geocoder from 'local-reverse-geocoder'
import { promisify } from 'util'
import slugify from '@sindresorhus/slugify'
import countryCode from 'country-code-lookup'

console.log('Initializing local-reverse-geocoder database...')
await promisify(geocoder.init.bind(geocoder))({
  load: {
    admin1: true,
    admin2: false,
    admin3And4: false,
    alternateNames: false,
  },
})

const fetch = createFetch.defaults({
  cachePath: 'node_modules/.cache',
  cache: 'force-cache',
  retry: 10,
})

const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)

const DATA_DIR = join(__dirname, '..', 'data')
const NOAA_SOURCE_NAME = 'US National Oceanic and Atmospheric Administration'
const STATIONS_URL =
  'https://api.tidesandcurrents.noaa.gov/mdapi/prod/webapi/stations.json'

const idMap = new Map()

async function main() {
  console.log('Creating harmonic stations:')
  const { stations: harmonicStations } = await fetch(
    `${STATIONS_URL}?type=harcon&expand=details&units=metric`,
  ).then((r) => r.json())

  for (const meta of harmonicStations) {
    idMap.set(meta.id, (await saveStation(await buildStation(meta))).id)
    process.stdout.write('.')
  }

  console.log(`\nDone. Created ${harmonicStations.length} stations.`)
  console.log('Creating subordinate stations:')

  let { stations: subordinateStations } = await fetch(
    `${STATIONS_URL}?type=tidepredictions&expand=details,tidepredoffsets&units=metric`,
  ).then((r) => r.json())
  // Only process subordinate stations
  subordinateStations = subordinateStations.filter((s) => s.type === 'S')

  for (const meta of subordinateStations) {
    // At least one station has both harmonic and subordinate data, skip if already created
    if (idMap.has(meta.id)) continue
    // At least one station lists itself as its own reference, but doesn't have harmonic data
    if (meta.id === meta.tidepredoffsets.refStationId) continue

    idMap.set(meta.id, (await saveStation(await buildStation(meta))).id)
    process.stdout.write('.')
  }

  console.log(`\nDone. Created ${subordinateStations.length} stations.`)
}

async function saveStation(data) {
  // FIXME: move this a normalization step
  const [[geo]] = await promisify(geocoder.lookUp.bind(geocoder))(data, 1)

  const { country } = countryCode.byIso(geo.countryCode) || {}
  const region = geo.admin1Code?.name || data.region
  const timezone = findTz(data.latitude, data.longitude)[0] || data.timezone

  // Replace country name in station name
  const name = data.name.replace(new RegExp(`, ${country}$`), '')

  const id = [country, region, name].filter(Boolean).map(slugify).join('/')

  Object.assign(data, {
    id,
    name,
    country,
    region,
    timezone,
  })

  const filePath = join(DATA_DIR, `${data.id}.json`)
  let dir = dirname(filePath)
  await mkdir(dir, { recursive: true })
  await writeFile(filePath, JSON.stringify(data, null, 2) + '\n')
  return data
}

async function buildStation(meta) {
  const station = {
    name: meta.name,
    region: meta.state,
    type: meta.type == 'S' ? 'subordinate' : 'reference',
    latitude: meta.lat,
    longitude: meta.lng,
    source: {
      name: NOAA_SOURCE_NAME,
      id: meta.id,
      published_harmonics: true,
      url: `https://tidesandcurrents.noaa.gov/stationhome.html?id=${meta.id}`,
      source_url: `https://api.tidesandcurrents.noaa.gov/mdapi/prod/webapi/stations/${meta.id}.json`,
    },
    license: {
      type: 'public domain',
      commercial_use: true,
      url: 'https://tidesandcurrents.noaa.gov/disclaimers.html',
    },
  }

  if (meta.type == 'S') {
    const refId = idMap.get(meta.tidepredoffsets.refStationId)
    if (!refId) {
      throw new Error(
        `Reference station ID ${meta.tidepredoffsets.refStationId} not found for subordinate station ${meta.id}`,
      )
    }

    Object.assign(station, {
      offsets: {
        reference: refId,
        height: {
          high: meta.tidepredoffsets.heightOffsetHighTide,
          low: meta.tidepredoffsets.heightOffsetLowTide,
        },
        time: {
          high: meta.tidepredoffsets.timeOffsetHighTide,
          low: meta.tidepredoffsets.timeOffsetLowTide,
        },
      },
    })
  } else {
    // Fetch full station details
    const res = await fetch(
      `https://api.tidesandcurrents.noaa.gov/mdapi/prod/webapi/stations/${meta.id}.json?expand=details,datums,harcon,disclaimers,notices&units=metric`,
    ).then((r) => r.json())
    const data = res.stations[0]

    // This should never happen, but just in case
    if (!data) throw new Error(`No data found for station ID: ${meta.id}`)

    // Write raw data to tmp for debugging
    writeFile(`tmp/noaa/${meta.id}.json`, JSON.stringify(data, null, 2))

    Object.assign(station, {
      harmonic_constituents: data.harmonicConstituents.HarmonicConstituents.map(
        (h) => ({
          name: h.name,
          description: h.description,
          amplitude: h.amplitude,
          phase_UTC: h.phase_GMT,
          phase_local: h.phase_local,
          speed: h.speed,
          // TODO: add comments
        }),
      ),
      datums: {
        ...(data.datums.LAT ? { LAT: data.datums.LAT } : {}),
        ...(data.datums.HAT ? { HAT: data.datums.HAT } : {}),
        // Some stations don't have all datums
        ...(data.datums.datums
          ? Object.fromEntries(data.datums.datums.map((d) => [d.name, d.value]))
          : {}),
      },
      disclaimers: (data.disclaimers.disclaimers ?? [])
        .map((d) => d.text)
        .join('\n'),
    })
  }

  return station
}

main().catch(console.error)
