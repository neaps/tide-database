#!/usr/bin/env node

import { writeFile, mkdir } from 'fs/promises'
import { join } from 'path'
import { fileURLToPath } from 'url'
import { dirname } from 'path'
import { find as findTz } from 'geo-tz/all'
import createFetch from 'make-fetch-happen'

const fetch = createFetch.defaults({
  cachePath: 'node_modules/.cache',
  cache: 'force-cache',
  retry: 10,
})

const __filename = fileURLToPath(import.meta.url)
const __dirname = dirname(__filename)

const DATA_DIR = join(__dirname, '..', 'data')
const NOAA_SOURCE_NAME = 'US National Oceanic and Atmospheric Administration'
const NEW_STATIONS_DIR = join(DATA_DIR, 'us')
const STATIONS_URL =
  'https://api.tidesandcurrents.noaa.gov/mdapi/prod/webapi/stations.json'

const idMap = new Map()

async function main() {
  console.log('Creating harmonic stations:')

  const { stations } = await fetch(
    `${STATIONS_URL}?type=tidepredictions&expand=details,tidepredoffsets&units=metric`
  ).then((r) => r.json())

  const referenceStations = stations.filter((s) => s.type === 'R')
  const subordinateStations = stations.filter((s) => s.type === 'S')

  console.log(`Fetched metadata for ${stations.length} stations.`)

  console.log('Creating reference stations:')
  for (const meta of referenceStations) {
    idMap.set(meta.id, (await saveStation(await buildStation(meta))).id)
    process.stdout.write('.')
  }

  console.log(`\nDone. Created ${referenceStations.length} reference stations.`)

  console.log('Creating subordinate stations:')

  for (const meta of subordinateStations) {
    // This should never happen, but just in case
    if (idMap.has(meta.id)) throw new Error("Duplicate station ID found: " + meta.id)

    // At least one station lists itself as its own reference, but doesn't have harmonic data
    if (meta.id === meta.tidepredoffsets.refStationId) continue

    idMap.set(meta.id, (await saveStation(await buildStation(meta))).id)
    process.stdout.write('.')
  }

  console.log(`\nDone. Created ${subordinateStations.length} stations.`)
}

function slugify(text) {
  return String(text)
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '')
}

async function saveStation(data) {
  let dir = NEW_STATIONS_DIR
  if (data.region) dir = join(dir, data.region.toLowerCase())
  const filePath = join(dir, `${slugify(data.name)}.json`)
  await mkdir(dir, { recursive: true })
  await writeFile(filePath, JSON.stringify(data, null, 2) + '\n')
  return data
}

async function buildStation(meta) {
  const id = slugify(['us', meta.state, meta.name].filter(Boolean).join('-'))

  const station = {
    id,
    name: meta.name,
    continent: 'North America',
    country: 'United States',
    region: meta.state,
    type: meta.type == 'S' ? 'subordinate' : 'reference',
    latitude: meta.lat,
    longitude: meta.lng,
    timezone: findTz(meta.lat, meta.lng)[0],
    source: {
      name: NOAA_SOURCE_NAME,
      id: meta.id,
      published_harmonics: true,
      url: `https://tidesandcurrents.noaa.gov/stationhome.html?id=${meta.id}`,
      source_url: `https://api.tidesandcurrents.noaa.gov/mdapi/prod/webapi/stations/${meta.id}.json`,
    },
    license: {
      type: 'public domain',
      commercial_use: true,
      url: 'https://tidesandcurrents.noaa.gov/disclaimers.html',
    },
  }

  if (meta.type == 'S') {
    const refId = idMap.get(meta.tidepredoffsets.refStationId)
    if (!refId) {
      throw new Error(
        `Reference station ID ${meta.tidepredoffsets.refStationId} not found for subordinate station ${meta.id}`
      )
    }

    Object.assign(station, {
      offsets: {
        reference: refId,
        height: {
          type: meta.tidepredoffsets.heightAdjustedType === 'R' ? 'ratio' : 'fixed',
          high: meta.tidepredoffsets.heightOffsetHighTide,
          low: meta.tidepredoffsets.heightOffsetLowTide,
        },
        time: {
          high: meta.tidepredoffsets.timeOffsetHighTide,
          low: meta.tidepredoffsets.timeOffsetLowTide,
        },
      },
    })
  } else {
    // Fetch full station details
    const res = await fetch(
      `https://api.tidesandcurrents.noaa.gov/mdapi/prod/webapi/stations/${meta.id}.json?expand=details,datums,harcon,disclaimers,notices&units=metric`
    ).then((r) => r.json())
    const data = res.stations[0]

    // This should never happen, but just in case
    if (!data) throw new Error(`No data found for station ID: ${meta.id}`)

    // Write raw data to tmp for debugging
    writeFile(`tmp/noaa/${meta.id}.json`, JSON.stringify(data, null, 2))

    Object.assign(station, {
      harmonic_constituents: data.harmonicConstituents.HarmonicConstituents.map(
        (h) => ({
          name: h.name,
          description: h.description,
          amplitude: h.amplitude,
          phase_UTC: h.phase_GMT,
          phase_local: h.phase_local,
          speed: h.speed,
          // TODO: add comments
        })
      ),
      datums: {
        ...(data.datums.LAT ? { LAT: data.datums.LAT } : {}),
        ...(data.datums.HAT ? { HAT: data.datums.HAT } : {}),
        // Some stations don't have all datums
        ...(data.datums.datums
          ? Object.fromEntries(data.datums.datums.map((d) => [d.name, d.value]))
          : {}),
      },
      disclaimers: (data.disclaimers.disclaimers ?? [])
        .map((d) => d.text)
        .join('\n'),
    })
  }

  return station
}

main().catch(console.error)
